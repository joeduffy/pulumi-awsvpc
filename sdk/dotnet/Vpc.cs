// *** WARNING: this file was generated by Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Awsvpc
{
    [AwsvpcResourceType("awsvpc:index:Vpc")]
    public partial class Vpc : Pulumi.ComponentResource
    {
        /// <summary>
        /// CIDR block for the VPC.
        /// </summary>
        [Output("cidrBlock")]
        public Output<string> CidrBlock { get; private set; } = null!;

        /// <summary>
        /// The ID of the underlying AWS VPC.
        /// </summary>
        [Output("id")]
        public Output<string> Id { get; private set; } = null!;

        /// <summary>
        /// Auto-assigned elastic IP addresses (EIPs) for the NAT gateway(s).
        /// </summary>
        [Output("natEips")]
        public Output<ImmutableArray<string>> NatEips { get; private set; } = null!;

        /// <summary>
        /// CIDR blocks for private subnets.
        /// </summary>
        [Output("privateSubnetCidrs")]
        public Output<ImmutableArray<string>> PrivateSubnetCidrs { get; private set; } = null!;

        /// <summary>
        /// IDs for private subnets.
        /// </summary>
        [Output("privateSubnetIds")]
        public Output<ImmutableArray<string>> PrivateSubnetIds { get; private set; } = null!;

        /// <summary>
        /// Route table IDs for private subnets.
        /// </summary>
        [Output("privateSubnetRouteTableIds")]
        public Output<ImmutableArray<string>> PrivateSubnetRouteTableIds { get; private set; } = null!;

        /// <summary>
        /// CIDR blocks for protected subnets.
        /// </summary>
        [Output("protectedSubnetCidrs")]
        public Output<ImmutableArray<string>> ProtectedSubnetCidrs { get; private set; } = null!;

        /// <summary>
        /// IDs for protected subnets.
        /// </summary>
        [Output("protectedSubnetIds")]
        public Output<ImmutableArray<string>> ProtectedSubnetIds { get; private set; } = null!;

        /// <summary>
        /// CIDR blocks for public subnets.
        /// </summary>
        [Output("publicSubnetCidrs")]
        public Output<ImmutableArray<string>> PublicSubnetCidrs { get; private set; } = null!;

        /// <summary>
        /// IDs for public subnets.
        /// </summary>
        [Output("publicSubnetIds")]
        public Output<ImmutableArray<string>> PublicSubnetIds { get; private set; } = null!;

        /// <summary>
        /// Route table ID for public subnets.
        /// </summary>
        [Output("publicSubnetRouteTableId")]
        public Output<string> PublicSubnetRouteTableId { get; private set; } = null!;

        /// <summary>
        /// If private subnets were created, an S3 VPC Endpoint to simplify S3 access.
        /// </summary>
        [Output("s3VpcEndpointId")]
        public Output<string?> S3VpcEndpointId { get; private set; } = null!;


        /// <summary>
        /// Create a Vpc resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Vpc(string name, VpcArgs? args = null, ComponentResourceOptions? options = null)
            : base("awsvpc:index:Vpc", name, args ?? new VpcArgs(), MakeResourceOptions(options, ""), remote: true)
        {
        }

        private static ComponentResourceOptions MakeResourceOptions(ComponentResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new ComponentResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = ComponentResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
    }

    public sealed class VpcArgs : Pulumi.ResourceArgs
    {
        [Input("availabilityZones")]
        private InputList<string>? _availabilityZones;

        /// <summary>
        /// List of AZs to use for the subnets in the VPC. Note: the logical order is preserved.
        /// </summary>
        public InputList<string> AvailabilityZones
        {
            get => _availabilityZones ?? (_availabilityZones = new InputList<string>());
            set => _availabilityZones = value;
        }

        /// <summary>
        /// CIDR block for the VPC.
        /// </summary>
        [Input("cidrBlock")]
        public Input<string>? CidrBlock { get; set; }

        /// <summary>
        /// Set to false to create only public subnets. If false, the CIDR parameters for ALL private subnets will be ignored.
        /// </summary>
        [Input("createPrivateSubnets")]
        public Input<bool>? CreatePrivateSubnets { get; set; }

        /// <summary>
        /// Set to true to create a network ACL protected subnet in each AZ. If false, the CIDR parameters for those subnets will be ignored. If true, it also requires that the `createPrivateSubnets` parameter is also true.
        /// </summary>
        [Input("createProtectedSubnets")]
        public Input<bool>? CreateProtectedSubnets { get; set; }

        /// <summary>
        /// Number of AZs to use in the VPC. If both are specified, this must match your selections in the list of AZs parameter.
        /// </summary>
        [Input("numberOfAvailabilityZones")]
        public Input<int>? NumberOfAvailabilityZones { get; set; }

        [Input("privateSubnetCidrs")]
        private InputList<string>? _privateSubnetCidrs;

        /// <summary>
        /// CIDR blocks for private subnets.
        /// </summary>
        public InputList<string> PrivateSubnetCidrs
        {
            get => _privateSubnetCidrs ?? (_privateSubnetCidrs = new InputList<string>());
            set => _privateSubnetCidrs = value;
        }

        [Input("privateSubnetTags")]
        private InputList<ImmutableDictionary<string, string>>? _privateSubnetTags;

        /// <summary>
        /// Tags to add to private subnets (an array of maps, one per AZ).
        /// </summary>
        public InputList<ImmutableDictionary<string, string>> PrivateSubnetTags
        {
            get => _privateSubnetTags ?? (_privateSubnetTags = new InputList<ImmutableDictionary<string, string>>());
            set => _privateSubnetTags = value;
        }

        [Input("protectedSubnetCidrs")]
        private InputList<string>? _protectedSubnetCidrs;

        /// <summary>
        /// CIDR blocks for protected subnets.
        /// </summary>
        public InputList<string> ProtectedSubnetCidrs
        {
            get => _protectedSubnetCidrs ?? (_protectedSubnetCidrs = new InputList<string>());
            set => _protectedSubnetCidrs = value;
        }

        [Input("protectedSubnetTags")]
        private InputList<ImmutableDictionary<string, string>>? _protectedSubnetTags;

        /// <summary>
        /// Tags to add to protected subnets (an array of maps, one per AZ).
        /// </summary>
        public InputList<ImmutableDictionary<string, string>> ProtectedSubnetTags
        {
            get => _protectedSubnetTags ?? (_protectedSubnetTags = new InputList<ImmutableDictionary<string, string>>());
            set => _protectedSubnetTags = value;
        }

        [Input("publicSubnetCidrs")]
        private InputList<string>? _publicSubnetCidrs;

        /// <summary>
        /// CIDR blocks for public subnets.
        /// </summary>
        public InputList<string> PublicSubnetCidrs
        {
            get => _publicSubnetCidrs ?? (_publicSubnetCidrs = new InputList<string>());
            set => _publicSubnetCidrs = value;
        }

        [Input("publicSubnetTags")]
        private InputList<ImmutableDictionary<string, string>>? _publicSubnetTags;

        /// <summary>
        /// Tags to add to public subnets (an array of maps, one per AZ).
        /// </summary>
        public InputList<ImmutableDictionary<string, string>> PublicSubnetTags
        {
            get => _publicSubnetTags ?? (_publicSubnetTags = new InputList<ImmutableDictionary<string, string>>());
            set => _publicSubnetTags = value;
        }

        /// <summary>
        /// The allowed tenancy of instances launched into the VPC.
        /// </summary>
        [Input("tenancy")]
        public Input<string>? Tenancy { get; set; }

        public VpcArgs()
        {
        }
    }
}
